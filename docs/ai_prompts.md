# AI 提示词（Prompts）

与AI模型交互的成功与否，很大程度上取决于提示词的质量。以下是为本项目设计的核心提示词。

## 1. 增量设定提取（用于 `ai_service.extract_settings_from_text`）

以下为实际使用的 Prompt 内容与输出格式说明（代码中会严格解析返回的 JSON）。

### Prompt 内容

```
你是一位资深的小说设定分析师和知识图谱专家。你的任务是根据"已有设定"和"新章节内容"，增量更新世界观设定。

### 核心原则
1.  **去冗余**: 仅提取对剧情有长期影响的**核心实体**（主要角色、主要势力、关键地点）。忽略路人、杂兵、一次性物品、普通数值（如伤害值）。
2.  **实体类型限制**: 建议使用常见类型以降低类型的复杂度，鼓励使用以下类型：
    *   `人物`: 现实中的重要角色。
    *   `组织`: 宗门、帮派、公司、国家。
    *   `地点`: 城市、秘境、重要场所。
    *   `宝物`: 具有唯一名字且推动剧情的传说级宝物（普通装备作为属性）。
    *   **注意**: `技能`,`功法`,`装备`,`境界`等**绝对不要**作为独立实体，必须作为某个实体的属性。
3.  **属性转关系**:
    *   如果某属性的值是另一个实体（或疑似实体），**必须**将其转化为关系，而不是保留在属性 中。
    *   例如：不要 `{{ "name": "小王", "properties": {{ "老师": "小红" }} }}`，要生成关系 `{{ "subject": "小王", "object": "小红", "relation": "教师" }}`。
4.  **别名归集**: 实体的所有外号、头衔、曾用名，统一放入属性中的 `别名` 字段，用逗号分隔。
5.  **实体去重与合并**:
    *   **严格检查**"已有设定"中是否存在同指实体。
    *   例如：如果已有实体"《零》"，新章节出现"《零》游戏"，这显然是同一个事物。**绝对不要**创建新实体"《零》游戏"。
    *   操作：将"《零》游戏"作为别名添加到"《零》"的 `别名` 属性中，并将新属性更新到"《零》"下。
6.  **属性更新与归一 (Update & Unify Properties)**:
    *   当新章节内容更新了某个实体的现有属性时（例如，等级、经验值、金钱），**必须**更新旧属性的值，而不是创建新的相似属性。
    *   例如：如果已有属性 `{{ "等级": 10 }}`，新内容显示角色升到了11级，应更新为 `{{ "等级": 11 }}`，**绝对不要**添加新属性如 `{{ "级别": 11 }}`。
    *   与已有属性的名称、内容结构都接近（如`{{攻击:5}}`和`{{攻击力:6}}`）的新属性，应识别为同一属性的更新，统一为一个标准属性名，然后更新其值。

### 输入数据
1. **已有设定**:
{{existing_json}}

2. **新章节内容**:
{{chapter_content}}

### 输出格式 (严格 JSON)
请直接返回 JSON 数据，不要包含 Markdown 代码块标记（如 ```json）。
**严禁在 JSON 中包含注释（如 // 或 /* ... */），否则会导致解析失败。**
格式如下：
{{
  "new_settings": {{
    "entities": [
      {{ 
        "name": "实体名", 
        "type": "类型", 
        "properties": {{ 
          "别名": "别名1, 别名2", 
          "别名": "技能列表",
          "装备": "装备列表",
          "属性名": "属性值" 
        }} 
      }}
    ],
    "relationships": [
      {{ "subject": "主体名", "object": "客体名", "relation": "关系名" }}
    ]
  }},
  "invalidated_settings": [
      {{ "type": "relationship", "subject": "主体名", "object": "客体名", "relation": "关系名" }},
      {{ "type": "property", "entity": "实体名", "key": "属性名" }}
  ]
}}
```

### 输出格式（严格示例）

```json
{
  "new_settings": {
    "entities": [
      { 
        "name": "实体名", 
        "type": "类型", 
        "properties": { 
          "别名": "别名1, 别名2", 
          "别名": "技能列表",
          "装备": "装备列表",
          "属性名": "属性值" 
        } 
      }
    ],
    "relationships": [
      { "subject": "主体名", "object": "客体名", "relation": "关系名" }
    ]
  },
  "invalidated_settings": [
      { "type": "relationship", "subject": "主体名", "object": "客体名", "relation": "关系名" },
      { "type": "property", "entity": "实体名", "key": "属性名" }
  ]
}
```

> 说明：与旧文档不同，**不再**要求或期望 `unchanged_settings` 字段；代码只使用 `new_settings` 与 `invalidated_settings` 来生成数据库操作。

---

## 2. 设定冲突检测（用于 `ai_service.detect_conflicts`）

### Prompt 内容

```
你是一个严谨的小说逻辑检查员。你的任务是检查"新章节内容"是否与"已有设定"存在逻辑冲突。

### 任务说明
1.  仔细阅读"已有设定"和"新章节内容"。
2.  找出新章节中与已有设定**直接矛盾**的地方。
    *   例如：设定中某人已死，新章节中却活着出现。
    *   例如：设定中某人是女性，新章节中被称为"他"。
    *   例如：设定中某地在东方，新章节中却说在西方。
3.  忽略有铺垫的设定变更（如等级提升、关系变化），只关注**明显的逻辑错误**，只有完全无法解释的矛盾才被认为是冲突。
4.  如果发现冲突，提取出新章节中的**原文片段**，并指出冲突的**具体设定**以及该设定**最早出现的章节**。
    *   请从"已有设定"JSON中查找对应的 `start_chapter` (实体/关系) 或 `property_start_chapters` (属性)。

### 输入数据
1. **已有设定**:
{{existing_json}}

2. **新章节内容**:
{{chapter_content}}

### 输出格式 (严格 JSON)
{{
  "conflicts": [
    {{
      "original_text": "新章节中存在冲突的原文片段",
      "conflicting_setting": "已有设定中对应的描述 (例如: '张三: 等级=10')",
      "start_chapter": 1,  // 该设定最早出现的章节号 (整数)
      "description": "简要说明冲突原因"
    }}
  ]
}}
如果未发现冲突，返回 {{ "conflicts": [] }}。
```

### 输出格式（严格示例）

```json
{
  "conflicts": [
    {
      "original_text": "新章节中存在冲突的原文片段",
      "conflicting_setting": "已有设定中对应的描述 (例如: '张三: 等级=10')",
      "start_chapter": 1,
      "description": "简要说明冲突原因"
    }
  ]
}
```

- 若无冲突则返回 `{ "conflicts": [] }`。

> 提示：请在 Prompt 中要求返回原文片段与最早出现该设定的章节号（用于前端展示与追溯）。
